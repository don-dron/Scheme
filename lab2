(define-syntax trace-ex
  (syntax-rules ()
    ((_ a)
     (begin
       (let* ((y a))
         (display 'y)
         (display " => ")
         (display y)
         (newline)
         y)
       )
     )
    ))
 
(define-syntax test
  (syntax-rules ()
    ((_ expression expected-result)
     (list (quote expression) expected-result))
    )
  )

(define (run-tests tests)
  (define (and-fold x xs)
    (if (null? xs)
        x
        (and-fold
         (and x (car xs))
         (cdr xs))))
  (and-fold #t
            (map run-test tests)))
#|(define (zip . xss)
  (if (or (null? xss)
          (null? (trace-ex (car xss)))) 
      '()
      (cons (map car xss)
            (apply zip (map cdr (trace-ex xss))))))
(zip '(1 2 3) '(one two three))|#

(define c 0)
(define (next)
  (set! c (+ 1 c))
  c)
(display (trace-ex (next)))
(newline)

;(load "unit-test.scm")
(define (run-test the-test)
  (let ((expression (car the-test)))
    (write expression)
    (let* ((result (eval expression (interaction-environment)))
           (status (equal? (cadr the-test) result)))
      (if status
          (display "ok")
          (display "FAIL"))
      (newline)
      (if (not status)
          (begin (display " Expected: ")
                 (write (cadr the-test))
                 (newline)
                 (display " Returned: ")
                 (write result)
                 (newline)))
      status)))
(define (signum x)
  (cond
    ((< x 0) -1)
    ((= x 0)  0) 
    (else     1)))
(define the-tests
  (list (test (signum -2) -1) (test (signum  0)  0) (test (signum  2)  1)))
;(run-tests the-tests)
(define (ref . x)
  (if (null? (cdr (cdr x)))
      (dos (car x ) (car (cdr x)))
      (vst (car x) (car (cdr x)) (cdr (cdr x)))
      )
  )                                                                                                                                                                                
(define (lst s l x)
  (if (equal? l x)
      (car s)
      (lst (cdr s) l (+ 1 x))
      )
  )

(define (dos s l)
  (if (exact? l) 
      (cond
        ((and (vector? s) (>= l 0) (integer? l) (< l (length (vector->list s)))) (lst (vector->list s) l 0))
        ((and (list? s)  (>= l 0) (integer? l) (< l (length s))) (lst s l 0))
        ((and (string? s)  (>= l 0) (integer? l) (< l (length (string->list s)))) (lst  (string->list s) l 0))
        (else #f)
        )
      #f
      )
  )
(define (vst s l t)
  (if (exact? l) 
      (cond
        ((and (vector? s) (>= l 0) (integer? l) (<= l (length (vector->list s))))
         (list->vector (sbr (vector->list s) l 0 t '())))
        ((and (list? s)  (>= l 0) (integer? l) (<= l (length s))) (sbr s l 0 t '()))
        ((and (string? s)  (>= l 0) (integer? l) (<= l (length (string->list s))) (char? (car t)))
         (list->string (sbr  (string->list s) l 0 t '())))
        (else #f)
        )
      #f
      )
  )
(define (sbr x y z a b)
  (if (equal? y z)
      (append (reverse b) a x)  
      (sbr (cdr x) y (+ 1 z) a (cons (car x) b))
      )
  )
#|(ref '(1 2 3) 1)
(ref #(1 2 3) 1)
(ref "123" 1)   
(ref "123" 3)   
(ref '(1 2 3) 1 0) 
(ref #(1 2 3) 1 0)   
(ref #(1 2 3) 1 #\0) 
(ref "123" 1 #\0)    
(ref "123" 1 0)      
(ref "123" 3 #\4)     
(ref "123" 5 #\4)   |#
(define
  (list (test (derivative (* 2 x) 2)
        (test (derivative (log x) (/ 1 x)))
        (test (derivative (sin x) (cos x)))
        (test (derivative (cos x) (- (sin (x)))))
        (test (derivative (expt x 10) (* 9 (expt x 9))))
        (test (derivative (/ 1 x) (- (/ 1 (* x x)))))
        (test (derivative (* 2 (sin x) (cos x)) (* 2 (cos (* 2 x)))))
        (test (derivative (* 2 (log x)) (* 2 (/ 1 x))))
        (test (derivative (3 * (/ 1 x)) (* 3 (- (/ 1 (* x x))))))
        (test (derivative (expt e 10) 0)
        (test (derivative (cos (* 2 x x)) (* 4 x (sin (* 2 x x)))))
        (test (derivative (- (* 2 x) 5) 2)
      )
  )
