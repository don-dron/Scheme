(define (day-of-week d m y)
  (let* ((a (quotient (- 14 m) 12)) (Y (- y a) ) (M (- (+ m (* 12 a) ) 2)) )
         ( remainder (- (+ 1400 d Y (quotient Y 4) (quotient Y 400) (quotient ( * 31 M ) 12)) (quotient Y 100)) 7))
 )
(define (my-gcd x y)
  ( if(= x y)
      x
      (if (> x y) (my-gcd (- x y) y) (my-gcd x (- y x)))))
(define (my-lcm x y)
  ( / (* x y) (my-gcd x y)))
(define (my-gcd x y)
  (if (= y 0)
      x
      (my-gcd y (remainder x y))))
(define (prime? x)
  (if (= x 0)
        (not (= x 0))
        (let ((n (- x 1))) (led n x))))
(define (led n x )
  (if (= n 1)
      (= n 1)
      ( if (= (remainder x n ) 0)
           (not (= (remainder x n ) 0))
           ( led (- n 1) x))))
(define (uu x)
  (floor (sqrt x)))
(define (bisection f a b e)
  (if(= (f a) 0)
     a
     (if(= (f b) 0)
        b
        (if(> (- b a) e)
           (let* (( y (/(- b a) 2)) ( c (+ a y)))
             (if (not (> (* (f a) (f c)) 0 ))
                 (bisection f a c e)
                 (bisection f c b e)))
           b))))   
(define (golden f a b e)
  (if (< (- b a) e)
      (/ (+ a b) 2)
      (let* (
             (U (/ (+ 1 (sqrt 5))2))
             (x1 (- b (/ (- b a) U)))
             (x2 (+ a (/ (- b a) U)))
             ) 
        (if (not ( < (f x1) (f x2)))
            (golden f x1 b e)
            (golden f a x2 e)
            )
        )
      )
  )
  (define (my-range a b d)
  (if (> b a )
      (cons a (my-range (+ d a) b d))
      '()))
(define (my-flatten a)
  (if (null? a)
      '()
      (if (list?  (car a))
          (append (my-flatten (car a)) (my-flatten (cdr a)))
          (cons (car a) (my-flatten (cdr a))))))
(define (my-element? x l)
  (if (null? l)
      (not (null? l))
      (if (equal? x (car l))
          (equal? x (car l))
          (my-element? x (cdr l)))))
(define (my-filter pred? l)
  (if (null? l)
      '()
      (if (pred? (car l))
          (cons (car l) (my-filter pred? (cdr l)))
          (my-filter pred? (cdr l)))))
(define (my-fold-left f l) (R f (car l) (cdr l)))
(define (R f x l)
  (if(null? l)
     x
     (R f (f x (car l)) (cdr l))))
(define (my-fold-right  f l) (Y f (car (reverse l)) (reverse l)))
(define (Y f x l)
  (if(null? (cdr l))
     x
     (Y f (f (car (cdr l)) x ) (cdr l))))
     (define (my-flatten a)
  (if (null? a)
      '()
      (if (list?  (car a))
          (append (my-flatten (car a)) (my-flatten (cdr a)))
          (cons (car a) (my-flatten (cdr a))))))
(define (insert x y)
  (if (null? x) y
      (if (null? y) x
          (if (< (car x) (car y))
              (cons (car x) (insert (cdr x) y))
              (cons (car y) (insert (cdr y) x))))))
(define (sort L)
  (if (null? L) '()
      (insert (list (car L)) (sort (cdr L)))))
(define (set-eq? f y)
  (if (list? y)
      (or (equal? f y) (equal? f (reverse y)))
      (equal? f y))) 

(define (list->set x) (reverse (povtor x '())))
(define (povtor s r)
  (if (null? s)
      r
      (if (> (proverka (car s) r) 0)
          (povtor (cdr s) r)
          (povtor (cdr s) (cons (car s) r)))))
  
(define (proverka k xs) (f 0 k xs))
(define (f c k xs)
  (cond
    ((null? xs) c)
    ((equal? (car xs) k) (f (+ 1 c) k (cdr xs)) ) 
    (else (f c k (cdr xs)))))
 
(define (intersection x y) (in (list->set x) (list->set y)))
(define (in x y)
  (if(null? x)
     '()
     (if(null?  y)
        '()
        (if (equal? (car x) (car y))
            (cons (car x) (in (cdr x) (cdr y)))
            (in (cdr x) y)))))

(define (union x y)
  (if (null? x)
      y
      (if(null? y)
         x
         (H (unio (append (list->set x) (list->set y)) (intersection (list->set x) (list->set y))) (intersection (list->set x) (list->set y)) (intersection (list->set x) (list->set y))))))

(define (unio x l)
  (if (null? x)
      '()
      (if (null? l)
          x
          (if (equal?(car x) (car l))
              (cons (car x) (unio (cdr x) l))
              (unio x (cdr l))))))
     
(define (symmetric-difference x y) (Q (append (list->set x)  (list->set y)) (intersection (list->set x)  (list->set y)) (intersection (list->set x)  (list->set y)) ))
(define (Q x y z)
  (if (null? x)
      (H x z z)
      (if (null? y)
          (H x z z)
          (if (equal?(car x) (car y))
              (Q (cdr x) (cdr y) z)
              (cons (car x) (Q (cdr x) y z ))))))    
(define (H x y z)
  (if (null? x)
      '()
      (if (null? y)
          x
          (if (equal? (car x) (car y))
              (H (cdr x) (cdr y) z)
              (cons (car x) (H (cdr x) y z))))))


(define (difference x y) (K (list->set x)  (list->set y)))
(define (K x y)
  (if (null? x)
      '()
      (if (null? y)
          x
          (if (not (= (car x) (car y)))
              (cons (car x) (K (cdr x) y))
              (K (cdr x) (cdr y))))))
  
(define (f x) (list->string (g x)))
(define (g x)
  (if (null? x)
      '()
      (if (null? (cdr x))
          '()
          (if (or (equal? (car x) #\space) (equal? (car x) #\tab) (equal? (car x) #\newline))
              (g (cdr x))
              x))))
(define (h x)  (list->string (reverse (k (reverse x)))))
(define (k x)
  (if (null? x)
      '()
      (if (null? (cdr x))
          '()
          (if (or (equal? (car x) #\space) (equal? (car x) #\tab) (equal? (car x) #\newline))
              (k (cdr x))
              x))))
(define (t x)  (f (string->list(h x))))
(define (Q x y)
  (if (null? x)
      #t
      (if (null? y)
          #f
          (if (equal? (car x) (car y))
              (Q (cdr x) (cdr y))
              #f))))
(define (D x y)
  (if (null? x)
      #t
      (if (null? y)
          #f
          (if (equal? (car x) (car y))
              (D (cdr x) (cdr y))
              (D x (cdr y))))))
(define (string-trim s) (t (string->list s))) 
(define (string-trim-left  s ) (f (string->list s)))
(define (string-trim-right  s ) (h (string->list s)))
(define (string-prefix? s l) ( Q (string->list s) (string->list l)))
(define (string-suffix? s l) ( Q (reverse (string->list s)) (reverse (string->list l))))
(define (string-infix? s l) ( D (string->list s) (string->list l)))
(define (string-split x y) (str (split (string->list x) (string->list y) (length (string->list y) ))))
(define (str l)
  (if (null? l)
      '()
      (cons (list->string (car l)) (str (cdr l)))))
(define (sborka x y z)
  (if(null? x)
     '()
     (if (null? (cdr x))
         x
         (if (string-prefix? (list->string y) (list->string x))
             '()
             (cons (car x) (sborka (cdr x) y z))))))
(define (split s l len)
  (if (null? s)
      '()
      (if (null? (cdr s))
          (list s)
          (if (string-prefix? (list->string l) (list->string s))
              (split (list-tail s len) l len)
              (cons (sborka s l len) (split (list-tail s (length (sborka s l len))) l len))))))
              (define (encode x) (pk x 1))
(define (pk x n)
  (if (null? x)
      '()
      (if (null? (cdr x))
          (list (cons (car x) (list n)))
          (if (equal? (car x) (car (cdr x)))
              (pk (cdr x) (+ 1 n))
              (append (list (cons  (car x) (list n)))  (pk (cdr x) 1))))))
(define (H xs y)
  (if(= y 0)
     '()
     (cons xs (H xs (- y 1)))))

(define (unpack x)
  (if (null? x)
      '()
      (if (null? (cdr x))
          (list (H (car (car x)) (car (cdr (car x)))))
          (append (list (H (car (car x)) (car (cdr (car x))))) (unpack (cdr x))))))
(define (decode x)
  (if (null? x)
      '()
      (if (null? (cdr x))
          (H (car (car x)) (car (cdr (car x))))
          (append (H (car (car x)) (car (cdr (car x)))) (decode (cdr x))))))

(define (pack x) (unpack (encode x)))
(define (ins L M prefix?)
  (if (null? L) M
      (if (null? M) L
          (if (prefix? (car L) (car M))
              (cons (car L) (ins (cdr L) M prefix?) )
              (cons (car M) (ins (cdr M) L prefix?))
              )
          )
      )
  )
(define (insertion-sort prefix? L)
  (if (null? L) '()
      (ins (list (car L)) (insertion-sort  prefix? (cdr L)) prefix?)
      )
  )
(define (selection-sort prefix? xs)
  (if (null? xs)
      '()
     (cons (small xs prefix?) (selection-sort prefix?  (live xs (small xs prefix?))))
      )
  )
(define (small xs prefix?)
  (if (null? (cdr xs))
      (car xs)
      (sm (car xs) (small (cdr xs) prefix?) prefix?)
      )
  )

(define (sm val1 val2 prefix?)
  (if (prefix? val1 val2)
      val1
      val2
      )
  )

(define (live xs val)
  (if (equal? val (car xs))
      (cdr xs)
      (cons (car xs) (live (cdr xs) val))))
      (define (make-multi-vector sizes . f)
  (let ((multi-vector (make-vector (+ (apply * sizes) 1))))
    (if (not (null? f))
        (vector-fill! multi-vector (car f))
        )
    (vector-set! multi-vector 0 (cons 'multi-vector sizes)) multi-vector))

(define (multi-vector-set! m indices x)
  (vector-set! m (apply * (map (lambda (x) (+ x 1)) indices)) x))

(define (multi-vector? m)
  (and (vector? m)
       (list? (vector-ref m 0))
       (equal? (car (vector-ref m 0)) 'multi-vector)))

(define (multi-vector-ref m indices)
  (vector-ref m (apply * (map (lambda (x) (+ x 1)) indices))))
(define ok #t)

(define (num? x)
  (and (> (char->integer x) 47) (< (char->integer x) 59)))

(define (numb xs b c d)
  (if (null? xs)
      c
      (if (num? (car xs))
          (if (> (- (char->integer (car xs)) 48) d)
              'number-conversion-error
              (numb (cdr xs) (* b d) (+ c (* b (- (char->integer (car xs)) 48))) d)
              )
          (if (> (remainder (- (char->integer (car xs)) 1) 32) (- d 11))
              1
              (numb (cdr xs) (* b d) (+ c (* b (+ (remainder (- (char->integer (car xs)) 1) 32) 10))) d)))))

(define (proverka xs b)
  (if (null? xs)
      (null? xs)
      (if (and (null? (cdr xs)) (equal? (car xs) #\0))
          (not (and (null? (cdr xs)) (equal? (car xs) #\0)))
          (if (num? (car xs))
              (if (> (- (char->integer (car xs)) 48)  b)
                  (not (> (- (char->integer (car xs)) 48)  b))
                  (proverka (cdr xs) b ))
              (if (> (remainder (- (char->integer (car xs)) 1) 32) (- b 11))
                  (not (> (- (char->integer (car xs)) 48)  b))
                  (proverka (cdr xs) b))))))
(define (correct-number? s b)
  (if (num? (car (reverse (string->list s))))
      (if (> (- (char->integer (car (reverse (string->list s)))) 48) b)
          (not (> (- (char->integer (car (reverse (string->list s)))) 48) b))
          (proverka (cdr (reverse (string->list s))) b ))
      (if (> (remainder (- (char->integer (car (reverse (string->list s)))) 1) 32) (- b 11))
          (not(> (remainder (- (char->integer (car (reverse (string->list s)))) 1) 32) (- b 11)))
          (proverka (cdr (reverse (string->list s))) b ))))

(define (mx x y z)
  (if (< x y)
      (/ y z)
      (mx x (* y z) z)))
(define (decimal->certain x y) (list->string (reverse (sum x y))))
(define (sum x y)
  (if (= x 0)
      '()
      (if (<= 10 (remainder x y))
          (cons (integer->char (+ (remainder x y ) 55)) (sum (quotient x y) y))
          (cons (integer->char (+ (remainder x y ) 48)) (sum (quotient x y) y)))))
(define (certain->decimal s b)
  (if (num? (car (reverse (string->list s))))
      (if (> (- (char->integer (car (reverse (string->list s)))) 48) b)
          'number-conversion-error
          (numb (cdr (reverse (string->list s))) b (- (char->integer (car (reverse (string->list s)))) 48) b))
      (if (> (remainder (- (char->integer (car (reverse (string->list s)))) 1) 32) (- b 11))
          'number-conversion-error
          (numb (cdr (reverse (string->list s))) b (+ (remainder (- (char->integer (car (reverse (string->list s)))) 1) 32) 10) b))))
 





